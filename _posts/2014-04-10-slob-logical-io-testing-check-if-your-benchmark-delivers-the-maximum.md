---
layout: post
title: 'SLOB Logical I/O testing: Check if your benchmark delivers the maximum'
date: 2014-04-10 14:50:29.000000000 +02:00
type: post
parent_id: '0'
published: true
password: ''
status: publish
categories:
- Slob
tags: []
meta:
  _edit_last: '40807211'
  publicize_linkedin_url: http://www.linkedin.com/updates?discuss=&scope=16310177&stype=M&topic=5860020806779703296&type=U&a=PQ7Z
  publicize_facebook_url: https://facebook.com/
  publicize_google_plus_url: https://plus.google.com/101126738655139704850/posts/5jk8E3Dtv4E
  _wpas_done_5547632: '1'
  _publicize_done_external: a:1:{s:11:"google_plus";a:1:{s:21:"101126738655139704850";b:1;}}
  publicize_twitter_user: BertrandDrouvot
  publicize_twitter_url: http://t.co/tbvUJVWCeO
  _wpas_done_2225791: '1'
  _wpas_done_2077996: '1'
  _wpas_skip_5536151: '1'
  _wpas_skip_5547632: '1'
  _wpas_skip_2225791: '1'
  _wpas_skip_2077996: '1'
author:
  login: bdrouvot
  email: bdtoracleblog@gmail.com
  display_name: bdrouvot
  first_name: ''
  last_name: ''
permalink: "/2014/04/10/slob-logical-io-testing-check-if-your-benchmark-delivers-the-maximum/"
---
<p>With this post, I would like to share one tip related to <a href="http://kevinclosson.wordpress.com/2013/05/02/slob-2-a-significant-update-links-are-here/" target="_blank">SLOB</a> Logical I/O testing when you need to find out the <strong>maximum</strong> "Logical read (blocks) per second" your "benchmark" is capable of.</p>
<p>The tip is the rule number two, but let's describe the well known rule number one first.</p>
<p><span style="text-decoration:underline;"><strong>Rule number one:</strong> </span>When testing Logical I/O you have to ensure that the AWR report generated by SLOB shows a "Buffer Hit %" of 100% and a "DB CPU" event that is more than 99% of the DB Time. That is to say something like:</p>
<pre style="padding-left:30px;">Instance Efficiency Percentages (Target 100%)
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
            <strong><span style="color:#008000;">Buffer  Hit   %:  100.00</span></strong>    In-memory Sort %:  100.00
-----------------------------------------------------------------


Top 10 Foreground Events by Total Wait Time
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
                                            Tota    Wait   % DB
Event                                 Waits Time Avg(ms)   time Wait Class
------------------------------ ------------ ---- ------- ------ ----------
<strong><span style="color:#008000;">DB CPU                                      184.           99.6</span></strong>
control file sequential read            176   .1       0     .0 System I/O
Disk file Mirror Read                    43    0       0     .0 User I/O
Disk file operations I/O                 45    0       0     .0 User I/O

</pre>
<p><strong><span style="text-decoration:underline;">Question:</span></strong> Is that enough to ensure that the "benchmark" delivered the maximum ?</p>
<p><span style="text-decoration:underline;"><strong>Answer:</strong></span> <strong><span style="color:#ff0000;">No</span></strong>, this is not enough.</p>
<p>For example during 2 Logical I/O tests (using only one reader), with those slob.conf parameters:</p>
<p><strong>UPDATE_PCT=0</strong><br />
<strong>RUN_TIME=180</strong><br />
<strong>WORK_LOOP=0</strong><br />
<strong>SCALE=1000</strong></p>
<p>I am able to generate (<span style="color:#008000;"><strong>With rule number one followed, </strong></span>that is to say DB CPU=99.6% and Buffer Hit=100%) this load profile:</p>
<pre style="padding-left:30px;">Load Profile                    Per Second   Per Transaction  Per Exec  Per Call
~~~~~~~~~~~~~~~            ---------------   --------------- --------- ---------
             DB Time(s):               1.0               8.9      0.00      1.09
              DB CPU(s):               1.0               8.8      0.00      1.09
      Redo size (bytes):           7,098.4          61,501.9
  <strong><span style="color:#ff0000;">Logical read (blocks):          35,568.6</span></strong>         308,171.6
</pre>
<p>Or this one:</p>
<pre style="padding-left:30px;">Â 
Load Profile                    Per Second   Per Transaction  Per Exec  Per Call
~~~~~~~~~~~~~~~            ---------------   --------------- --------- ---------
             DB Time(s):               1.0               8.8      0.00      0.69
              DB CPU(s):               1.0               8.8      0.00      0.69
      Redo size (bytes):           6,684.2          57,877.5
  <span style="color:#008000;"><strong>Logical read (blocks):       1,075,426.1</strong></span>       9,312,012.1
</pre>
<p>As you can see the number of Logical I/O per second delivered during the 2 benchmarks are completely different. Going from about 35 000 to about 1 million <strong>even if</strong> :</p>
<ol>
<li><strong>The database did not record any wait events, meaning DB CPU is &gt; 99%</strong></li>
<li><strong>The Buffer Hit is 100%</strong></li>
<li><strong>The number of reader is the same (One in this case: DB TIME = 1 second per second)</strong></li>
</ol>
<p><span style="text-decoration:underline;"><strong>So, how can I check that the "benchmark" delivered the maximum ?</strong></span></p>
<p>As slob launchs a query to generate the I/O, we have to check that the elapsed time(s) of the query is about "run time(s) * number of readers" that is to say 180 seconds in our case.</p>
<p>Let's check the AWR "SQL ordered by Elapsed Time" section.</p>
<p><span style="text-decoration:underline;">For the 35 000 Logical I/O run:</span></p>
<pre style="padding-left:30px;">        Elapsed                  Elapsed Time
        Time (s)    Executions  per Exec (s)  %Total   %CPU    %IO    SQL Id
---------------- -------------- ------------- ------ ------ ------ -------------
           180.0              1        180.02   96.9   99.6     .0 0c1s032jgyrd7
Module: SQL*Plus
DECLARE v_default_schema_number PLS_INTEGER := '1'; v_update_pct PLS_INTEGER :=
'0'; v_max_loop_iterations PLS_INTEGER := '0'; v_seconds_to_run PLS_INTEGER := '
180'; v_scale PLS_INTEGER := '1000'; v_work_unit PLS_INTEGER := '1' ; v_redo_str
ess VARCHAR2(12) := 'HEAVY'; v_shared_data_modulus PLS_INTEGER := '0'; v_nt_arg

            <span style="color:#ff0000;"><strong>72.1</strong></span>      3,230,605          0.00   38.8   99.9     .0 bhdvtsvjhgvrh
Module: SQL*Plus
<span style="color:#ff0000;"><strong>SELECT COUNT(C2) FROM CF1 WHERE ( CUSTID &gt; ( :B1 - :B2 ) ) AND (CUSTID &lt; :B1 )
</strong></span></pre>
<p><span style="text-decoration:underline;">For the 1000000 Logical I/O run:</span></p>
<pre style="padding-left:30px;">        Elapsed                  Elapsed Time
        Time (s)    Executions  per Exec (s)  %Total   %CPU    %IO    SQL Id
---------------- -------------- ------------- ------ ------ ------ -------------
           180.0              1        180.03   96.9   99.6     .0 g41kknwap6na9
Module: SQL*Plus
DECLARE v_default_schema_number PLS_INTEGER := '1'; v_update_pct PLS_INTEGER :=
'0'; v_max_loop_iterations PLS_INTEGER := '0'; v_seconds_to_run PLS_INTEGER := '
180'; v_scale PLS_INTEGER := '1000'; v_work_unit PLS_INTEGER := '1000' ; v_redo_
stress VARCHAR2(12) := 'HEAVY'; v_shared_data_modulus PLS_INTEGER := '0'; v_nt_

           <strong><span style="color:#008000;">172.1</span></strong>        195,156          0.00   92.7   99.7     .0 bhdvtsvjhgvrh
Module: SQL*Plus
<strong><span style="color:#008000;">SELECT COUNT(C2) FROM CF1 WHERE ( CUSTID &gt; ( :B1 - :B2 ) ) AND (CUSTID &lt; :B1 )
</span></strong></pre>
<p>As you can see during the 1000000 Logical I/O run, the elapsed time of the SQL responsible of the Logical I/O is about 172 seconds while it is only about 72 seconds into the 35 000 Logical I/O run.</p>
<p><span style="text-decoration:underline;"><strong>Which lead me to the rule number 2:</strong></span> We have to check that the elapsed time(s) of the SQL responsible of the Logical I/O is about "number of readers * run time(s)".</p>
<p>For example for a run time of 180 seconds and 20 readers (./runit.sh 20) you should observe something like:</p>
<pre style="padding-left:30px;">        Elapsed                  Elapsed Time
        Time (s)    Executions  per Exec (s)  %Total   %CPU    %IO    SQL Id
---------------- -------------- ------------- ------ ------ ------ -------------
 **3,487.2** 2,710,259 0.00 96.7 99.7 .0 bhdvtsvjhgvrh Module: SQL\*Plus **SELECT COUNT(C2) FROM CF1 WHERE ( CUSTID \> ( :B1 - :B2 ) ) AND (CUSTID \< :B1 )** 

**Remarks:**

1. I had to play with the "WORK\_UNIT" slob parameter to reach 1000000 Logical I/O per second.
2. WORK\_UNIT=256 per default (which was not enough on my system to deliver the maximum Logical I/O per second): You may need to increase it as well if the rule number 2 is not followed.

**Conclusion:**

To ensure that your SLOB benchmark delivers the maximum Logical I/O per second, you need to check:

1. That the AWR report generated by SLOB shows a "Buffer Hit %" of 100% and a "DB CPU" event that is more than 99% of the DB Time.
2. That the elapsed time(s) of the SQL responsible of the Logical I/O is about "number of readers \* run time(s)". If not, you may need to increase the WORK\_UNIT slob parameter.

&nbsp;

